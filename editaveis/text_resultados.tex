\chapter{Resultados}
Neste capítulo serão apresentados os resultados obtidos pelo algoritmo Pollard-rho e suas variações juntamente com a descrição dos parâmetros utilizados.

\section{Descrição dos experimentos}
\begin{enumerate}

\item Implementar os seguintes algoritmos para solucionar o problema do logaritmo discreto para curvas elípticas:
  \begin{itemize}
  \item Pollard-rho com único processador.
  \item Pollard-rho com paralelização.
  \item Pollard-rho com múltiplos processadores.
  \end{itemize}
\item Escolher curvas e seus parâmetros cuja criptografia possa ser ``quebrada'' em um tempo adequado para que as comparações entre os diversos algoritmos possam ser realizadas.
\item Escolher pontos \(P\) e \(Q\) pertencentes à curva e elaborar o problema do logaritmo discreto.
\item Solucionar o problema utilizando os algoritmos implementados.
\item Verificar o tempo de execução necessário para cada algoritmo resolver o problema.
\item Comparar o tempo de execução dos algoritmos entre si.
% \item Verificar se os resultados obtidos condizem com os resultados esperados de acordo com a bibliografia pesquisada.

\end{enumerate}

\section{Escolha das curvas}
As curvas escolhidas para a execução dos testes foram geradas com o auxílio da biblioteca SageMath. Quanto aos parâmetros, foi escolhido um número primo \(p\) para representar o corpo finito no qual a curva está definida. Os parâmetros \(a\) e \(b\) foram selecionados seguindo a regra estabelecida na Equação \ref{eq:7}. Após isso, foi feito o cálculo da ordem da curva, se a ordem é prima, a curva é utilizada, caso contrário, será descartada e outra curva será gerada seguindo os mesmos passos citados, até que seja encontrada uma curva com a ordem prima. Dessa forma, pode-se evitar ataques baseados na fatoração da ordem da curva, tais como o ataque utilizando o algoritmo de Pohlig-Hellman (Seção \ref{sec:algs}).

Gerou-se diferentes curvas variando o valor de \(p\) de 32 a 160 bits para, posteriormente, realizar a comparação de tempo entre os algoritmos. Foram também selecionados dois pontos \(P\) e \(Q\) pertencentes à curva. Por fim, todas essas informações foram armazenadas em um arquivo de texto para ser processado pelos algoritmos.

\section{Implementação e execução dos algoritmos}

\subsection{Pollard-rho serial}
Para realizar a implementação do Pollard-rho com único processador (serial) seguiu-se a descrição do pseudo-algoritmo no Anexo \ref{alg:single} juntamente com a teoria explanada na Seção \ref{sec:single}. O ponto inicial foi escolhido de forma arbitrária para cada vez que o algoritmo fosse executado e foi utilizado apenas um processador, pois esta abordagem não possui suporte à paralelização.

A maior vantagem desse algoritmo é que ele necessita de uma quantidade ínfima de memória, pois utiliza o ciclo de Floyd, descrito na seção~\ref{floyd}. Dessa forma, este algoritmo pode ficar executando por tempo indeterminado mesmo em uma máquina com pouca memória.

\subsection{Pollard-rho com paralelização}
Buscando aproveitar a baixa quantidade de memória utilizada pelo Pollard-rho serial, e diminuir o tempo necessário para resolver o problema do logaritmo discreto, foi implementada uma versão modificada do algoritmo serial para que o código pudesse executar de forma paralela, afim de poder utilizar todos os processadores disponíveis da máquina. Por isso, este algoritmo difere do algoritmo serial apenas do ponto de vista estatístico.

Basicamente são utilizados \(M\) núcleos (virtuais) em que cada um executa um processo rodando o algoritmo Pollard-rho de forma independente, com diferentes pontos iniciais \(X_0\) aleatórios, enquanto o algoritmo serial seleciona apenas um ponto incial. Por mais que esta abordagem não seja a mais eficiente em termos de tempo execução, essa medida obteve melhorias, as quais serão apresentados na Seção \ref{sec:execution_time}.

\subsection{Pollard-rho com múltiplos processadores}
O algoritmo mais eficiente é o Pollard-rho com múltiplos processadores (multiprocessado), pois este é diferente em relação aos outros algoritmos quanto à técnica e o tempo esperado de processamento, de acordo com a Seção \ref{sec:parallelized}. A utilização de um servidor central para o armazenamento de pontos é o ponto positivo do algoritmo, pois o processo que calcula os pontos ganha em velocidade por não ter a responsabilidade de checar a colisão entre os pontos e também por evitar a necessidade de um recurso compartilhado entre os processos, já que o servidor central é o único responsável por armazenar e checar a colisão entre os pontos.

O ponto negativo dessa abordagem é que o servidor não pode armazenar infinitos pontos, pois existe o limite da memória RAM. Para isso utilizou-se a propriedade distintiva (Seção \ref{sec:distinguished}), que vai limitar a quantidade de pontos que o servidor irá armazenar. Porém, caso essa propriedade seja muito restritiva, a possibilidade de encontrar uma colisão diminui, pois o servidor central terá um espaço amostral de pontos menor para encontrar uma colisão, e consequentemente, o tempo de execução do algoritmo irá aumentar. Por outro lado, caso a propriedade for muito abrangente, a memória pode esgotar rapidamente. Dessa forma, é necessário encontrar um equilíbrio para essa propriedade distintiva, pois quanto mais abrangente, maior a quantidade de memória utilizada para armazenar os pontos, quanto mais restritiva, menor a quantidade de pontos armazenados e maior o tempo para encontrar uma colisão entre estes pontos.

Durante a execução desse algoritmo, foram feitos diversos testes sobre a utilização da propriedade distintiva mais adequada até chegar a uma que fosse considerada boa. A propriedade escolhida foi o \textit{Hamming weight} da coordenada x do ponto ser menor que 24. Além da dificuldade inerente a essa propriedade, ficou evidente também o problema de memóra RAM, pois, apesar da utilização de uma propriedade distintiva para armazenar os pontos (o que diminui o número de pontos a serem armazenados), 16GB de memória se tornavam insuficientes após aproximadamente 25 horas de execução do algoritmo, resultando em falta de memória a partir de uma curva de 66 bits.

\section{Tempo de execução}
\label{sec:execution_time}

\begin{table}[h]
\centering
\label{table:results}
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor[gray]{0.9}
\multicolumn{1}{|c|}{\(bits\)} & \textbf{Serial} & \textbf{Paralelizado} & \textbf{Multiprocessado} \\ \hline
32                             & 0h00m01s        & 0h00m01s              & 0h00m01s                 \\ \hline
36                             & 0h00m08s        & 0h00m04s              & 0h00m01s                 \\ \hline
40                             & 0h00m46s        & 0h00m19s              & 0h00m03s                 \\ \hline
44                             & 0h02m58s        & 0h01m26s              & 0h00m14s                 \\ \hline
48                             & 0h17m11s        & 0h14m47s              & 0h01m04s                 \\ \hline
52                             & 0h20m26s        & 0h16m49s              & 0h04m54s                 \\ \hline
56                             & 1h27m28s        & 2h46m18s              & 0h29m12s                 \\ \hline
60                             & 15h11m05s       & 8h56m45s              & 0h41m38s                 \\ \hline
64                             & 2d 14h37m58s    & 1d 15h52m12s          & 6h44m23s                 \\ \hline
65                             & 3d 20h45m48s    & -                     & 10h33m34s                \\ \hline
66                             & 6d 04h30m10s    & -                     & -                        \\ \hline
\end{tabular}
\caption{Resultado dos algoritmos Pollard-rho}
\end{table}

Com os experimentos realizados durante este trabalho, foi possível realizar uma comparação empírica entre três variantes do algoritmo Pollard-rho para ataques à criptografia de curvas elípticas. Assim, foi possível verificar os pontos fortes e as fragilidades que cada uma das abordagens oferece, bem como verificar na prática a dificuldade computacional para resolver o problema do logaritmo discreto.

Os resultados apresentados na tabela \ref{table:results} demonstram que utilizar múltiplos processos para a solução do problema é a abordagem que oferece um desempenho melhor caso seja levado em consideração apenas o tempo de execução do algoritmo. Já em contrapartida, essa abordagem traz uma preocupante restrição física para sua implementação, que é a quantidade de memória necessária para a realização dos experimentos.

Para amenizar esse problema, foi utilizado uma propriedade distintiva que selecionava os pontos que deveriam ser armazenados na memória, descartando todos os outros pontos que não atendiam tal propriedade. A escolha dessa propriedade distintiva oferece um \textit{trade-off} inevitável, pois, caso seja selecionada uma propriedade muito restritiva, a quantidade de pontos armazenados será significativamente menor, aumentando o ``tempo de vida'' da memória e permitindo que o algoritmo seja executado por mais tempo. Porém, ao restringir muito a quantidade de pontos armazenados, o espaço amostral que o algoritmo dispõe para encontrar uma colisão é menor, e portanto, será necessário mais processamento para encontrar uma colisão, e consequentemente, o tempo necessário para resolver o problema do logaritmo discreto será maior. Diante desse \textit{trade-off}, pode-se verificar a importância da escolha dessa propriedade distintiva, algo que necessita e merece mais pesquisas por parte da comunidade acadêmica.

Já os algoritmos Pollard-rho serial e paralelo não possuem o problema da memória que a versão com múltiplos processadores apresenta. A vantagem desses algoritmos é utilizar sempre a mesma quantidade de memória para os cálculos, ou seja, o consumo de memória será sempre o mesmo durante toda a execução do algoritmo. Porém, é possivel perceber pela tabela \ref{table:results} que esses algoritmos são mais lentos para resolver o problema do logaritmo discreto.

A melhoria de desempenho do algoritmo paralelo em relação ao serial é justificada por uma questão estatística, pois o algoritmo serial escolhe um ponto inicial de forma aleatória, e dependendo dessa escolha, o algoritmo pode demorar mais tempo para encontrar uma colisão. Já na versão paralelizada, o mesmo algoritmo serial é executado em paralelo por vários processos, onde cada um deles é inicializado com um ponto inicial. Dessa forma, um desses processos vai partir de um ponto inicial mais propício a encontrar uma colisão do que os outros processos, e consequentemente, este processo irá encontrar uma colisão em um tempo menor do que os outros.

Os resultados da tabela \ref{table:results} podem ser colocados em um gráfico \textit{Mono-Log}, onde a coordenada $x$ do gráfico representa o tamanho da curva em \textit{bits} e a coordenada $y$ representa o tempo, em segundos, necessário para resolver o problema do logaritmo discreto. O resultado é o gráfico da figura~\ref{grafico1}.

Pelo gráfico da figura~\ref{grafico1} é possível perceber que os resultados experimentais se aproximam de uma reta. Isto demonstra que pode-se obter uma função que irá calcular o tempo aproximado para resolver o problema do logarítmo discreto partindo do tamanho da curva em bits, e que esta função é exponcial do tipo \(y = ke^{cx}\), onde $e$ é a base dos logarítmos neperianos.

\begin{figure}
\centering
\includegraphics[scale=0.6, bb=0 0 515 478]{figuras/grafico1.eps}
\caption{Tamanho em \textit{bits} X Tempo em segundos}
\label{grafico1}
\end{figure}

É importante saber que na geração dos resultados deste trabalho foi possível utilizar apenas uma máquina para a execução dos algoritmos, o que garante que as características de hardware utilizadas foram as mesmas, porém essa medida acaba comprometendo bastante tempo do cronograma. Até porque foram executados ao menos quatro vezes a mesma curva, por conta da característica do algoritmo que seleciona um ponto inicial de forma aleatória a cada nova execução. Os resultados da tabela mostram valores referentes à média dos tempos coletados para os valores de \textit{bits}.
