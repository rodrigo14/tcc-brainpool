\chapter{Considerações finais}
O presente trabalho apresentou os principais conceitos matemáticos da criptografia de curvas elípticas mais pertinentes à solução do problema do logaritmo discreto relacionado à curvas elípticas (ECDLP). Além disto, foi apresentado o algoritmo Pollard-rho, atualmente considerado o mais eficiente no ataque à criptografia de curvas elítpticas, e os conceitos nos quais este algoritmo se baseia. Foram realizadas implementações de três versões deste algoritmo (as versões serial, paralelizada e multiprocessada), as quais foram utilizadas em um número de testes incluindo alguns em que foi variado o número de processadores (núcleos) empregados. Finalmente os tempos de execução para a ``quebra'' da criptografia de curva elíptica na execução destas diferentes versões foram anotados e comparados.

% Em termos de resultados observou-se que a versão multiprocessada do algoritmo Pollard-rho se mostrou a mais eficiente. Comparando-se os tempos de execução, utilizando-se parâmetros de curvas elípticas de 64 bits, entre a versão serial ($t_s \approx 2318$ min) e a versão multiprocessada do algoritmo utilizando-se 8 núcleos ($t_{mp} \approx 345$ min) verificou-se uma relação de 6,7 para 1.

Outro resultado observado foi uma diminuição no tempo de processamento que ocorre inversamente proporcional ao número de núcleo empregados, sendo que a partir de seis processadores isso se torna um gargalo.

Para realização deste trabalho foi preciso ter um espírito investigativo para pesquisar as melhores soluções, tomar as melhores decisões de projeto e escolher as ferramentas mais adequadas, objetivando desenvolver um trabalho com a melhor qualidade possível, enquanto otimizando o esforço dispensado. Neste contexto, os conhecimentos de matemática, probabilidade e estatística, criptografia e, especialmente, de engenharia de software, adquiridos ao longo do Curso de Engenharia de Software na FGA foram de suma importância para que pudéssemos implementar os algoritmos Pollard-rho da forma mais eficiente e com a melhor performance possível. Dentre os tradeoffs e decisões de projeto ao longo do desenvolvimento deste TCC podemos destacar:

\begin{enumerate}
\item A escolha do algoritmo Pollard-rho multiprocessado para a utilização eficiente do poderio computacional hoje disponível a pesquisadores e desenvolvedores;

\item A escolha da linguagem Python para poupar esforço de desenvolvimento de
software em áreas que não eram o objetivo maior do projeto;

\item A utilização de múltiplos processos em Python, ao invés de múltiplas threads, visto que em Python múltiplas threads são executadas no mesmo processador (núcleo) devido a uma limitação do sistema de run-time da linguagem;

\item A escolha da linguagem C/C++, ainda uma das mais eficientes da atualidade, utilizada no desenvolvimento de sistemas embarcados, para se fazer uma comparação mais apropriada com a linguagem Python (que é interpretada).

\item A escolha da propriedade distintiva dos pontos distintos do algoritmo Pollard-rho, objetivando o melhor tradeoff possível entre o uso de memória RAM e o tempo de execução do algoritmo.
\end{enumerate}

Finalmente, gostaríamos de reiterar que este projeto nos suscitou a oportunidade de aplicar vários dos conhecimentos teóricos adquiridos durante o curso à solução de um problema real e importante no universo da segurança da informação, área extremamente em demanda no mundo profissional do engenheiro de software de hoje, alem de solidificar o aprendizado estes conhecimentos.

\section{Trabalhos futuros}
Como sugestões de continuidade do projeto, existem algumas etapas ou passos importantes para melhorar ainda mais o desempenho dos algoritmos. São elas:

\begin{enumerate}
	\item \textit{Aprofundar a pesquisa sobre a propriedade distintiva dos pontos}: por ser uma propriedade determinante para a execução do algoritmo Pollard-rho com múltiplos processadores, por si só é uma etapa que merece um estudo mais aprofundado.
	\item \textit{Implementar o algoritmo Pollard-rho com automorfismo}: apesar de ter sido apresentada a teoria necessária para aplicar o Pollard-rho com automorfismo, este algoritmo não foi contemplado na parte de resultados do trabalho, pois exige um alto nível de complexidade de implementação para que pudesse ser concluído neste trabalho. Pois é necessário encontrar uma função \(\psi\) que seja um automorfismo para cada uma das curvas geradas e isso requer um grande esforço.
	\item \textit{Implementar uma versão do código em C/C++}: apesar da facilidade, eficiência e ter um foco matemático, Python é uma linguagem de alto nível interpretada, enquanto a linguagem C/C++ é de médio nível, pois combina características de linguagens de alto e baixo níveis, por isso vale a pena realizar testes para essa linguagem e comparar observar seus resultados.
	\item \textit{Implementar o algoritmo Pollard-rho multiprocessado num supercomputador (múltiplos nós, nós com múltiplos núcleos e com GPUs)}: isto traria uma  dimensão maior e mais real ao aspecto da possibilidade de utilização efetiva do algoritmo Pollard-rho na área de criptoanálise.
\end{enumerate}
